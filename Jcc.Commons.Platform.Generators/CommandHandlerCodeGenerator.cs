using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Text;

namespace Jcc.Commons.Platform.Generators;

/// <summary>
/// Incremental Source Generator que detecta automáticamente clases que implementan
/// ICommandHandler&lt;TRequest, TResponse&gt; y genera el código de registro en el
/// inyector de dependencias (DependencyInjectionConfig.g.cs).
/// </summary>
[Generator]
public class CommandHandlerSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var commandHandlerClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsCommandHandlerCandidate(node),
                transform: static (ctx, _) => ExtractCommandHandlerInfo(ctx)
            )
            .Where(static info => info is not null)
            .Collect();

        context.RegisterSourceOutput(commandHandlerClasses, static (spc, list) =>
        {
            var handlers = list.Cast<CommandHandlerInfo>().ToImmutableArray();
            var generated = CommandHandlerCodeGenerator.GenerateDependencyInjectionCode(handlers);
            spc.AddSource("DependencyInjectionConfig.Commands.g.cs", generated);
        });
    }

    private static bool IsCommandHandlerCandidate(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDeclaration
            && classDeclaration.BaseList is not null
            && classDeclaration.BaseList.Types.Any(baseType =>
                baseType.Type.ToString().StartsWith("ICommandHandler"));
    }

    private static CommandHandlerInfo? ExtractCommandHandlerInfo(GeneratorSyntaxContext context)
    {
        if (context.Node is not ClassDeclarationSyntax classDeclaration)
            return null;

        var symbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;
        if (symbol is null || symbol.IsAbstract)
            return null;

        var commandInterface = symbol.AllInterfaces
            .FirstOrDefault(i => i.Name == "ICommandHandler" && i.TypeArguments.Length == 2);

        if (commandInterface is null)
            return null;

        var requestType = commandInterface.TypeArguments[0];
        var responseType = commandInterface.TypeArguments[1];

        return new CommandHandlerInfo(
            ClassName: symbol.Name,
            FullClassName: symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
            Namespace: symbol.ContainingNamespace.ToDisplayString(),
            RequestType: requestType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
            ResponseType: responseType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
            InterfaceFullName: commandInterface.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
        );
    }
}

internal record CommandHandlerInfo(
    string ClassName,
    string FullClassName,
    string Namespace,
    string RequestType,
    string ResponseType,
    string InterfaceFullName
);

internal static class CommandHandlerCodeGenerator
{
    public static string GenerateDependencyInjectionCode(ImmutableArray<CommandHandlerInfo> handlers)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// Generado por CommandHandlerSourceGenerator");
        sb.AppendLine();
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Jcc.Commons.Platform.Domain;");
        sb.AppendLine();
        sb.AppendLine("namespace Jcc.Commons.Platform.Infraestructure.Configuration;");
        sb.AppendLine();
        sb.AppendLine("public static partial class DependencyInjectionConfig");
        sb.AppendLine("{");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// Registra automáticamente todos los CommandHandlers en el contenedor DI.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static IServiceCollection AddGeneratedCommandHandlers(this IServiceCollection services)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (services == null) throw new ArgumentNullException(nameof(services));");
        sb.AppendLine();

        foreach (var handler in handlers.OrderBy(h => h.ClassName))
        {
            sb.AppendLine($"        // Registrar {handler.ClassName}");
            sb.AppendLine($"        services.AddScoped(typeof({handler.InterfaceFullName}), typeof({handler.FullClassName}));");
            sb.AppendLine($"        services.AddScoped(typeof({handler.FullClassName}));");
            sb.AppendLine();
        }

        sb.AppendLine("        return services;");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }
}
